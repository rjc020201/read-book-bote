头指针是指向第一个节点的指针，而头节点就是一个为了方便而设置的一个管理整个链表的首节点而已，一般头指针直接指向头节点，但是首元节点才是真正存数据的节点，当没有头节点的时候头指针就会指向首元节点

当你要大量查找某个位置的元素的时候，使用顺序链表的速度会更快，如果是尾插元素并且你已经申请的顺序链表的量足够大那么尾插的时候会更具备优势

栈的存储方式是后面存进来的先出去，这样的出入的顺序不能被打乱，而队列的存储方式是先存进来的先出去，二者的存储和将数据放出的顺序不一样，顺序栈可以共享存储空间，但是队列不可以，但是二者都可以用链表或者数组来实现，二者都是线性结构，插入和删除操作都可以是O(1);

这是符合队列的结构的想要满足题意，同时8后面只能放上9，同时这里就占了一个车道，然后就是4只能独立一条车道，2也是，5放在4之后，3放在2之后，9放在8之后，1只能独立一条，6放在5之后，7放在6之后，共计4条车道，这里的程序实现可以使用观测任意一条队列的出队头，当出队头都小于当前的序号的话就另开一条道

这里的实现是单向的，只能从队列向栈来保存输出，所以对于第一个序列，输出56之前只能借助栈来保存剩下的元素，同时34依次入栈，然后就会出现43出栈，这样就会得到第一个序列，同样道理第二34出去之前要用栈保存12，但是这样之后的12是逆序输出的，第二中是正序的，这个的算法实现可能就是比对两个数据结构和序列，当对头和序列吻合的时候就输出，不吻合就和栈比对，和栈顶吻合也输出，同时还不吻合就将队列的元素保存到栈中，再次进行判断，如果队列空了并且栈非空并且不吻合就是错的





需要一个栈和队列，操作1：入栈，汽车进入停车场的时候就是一次入栈操作，2判断栈是否满了，这样就可以判断是否让后来的车入栈3入队，这样就可以让后来的车放入队列中等待4出队并入队，这样是在有车开走之前来确定可以进入车库4出栈，这样的当有车想出去的时候就将栈顶弹至该车，同时要有另外一个栈来保存出去的车辆5将原先出栈进入别的栈的车辆重新pop并且重新push到原来的栈（车库）6计时器，可能需要一个链表来保存，每当一辆车离开了车库对应链表上的定时器就可以重置，同时消去这个节点，并生成一个新的计时器尾插或者头插进入链表

直接进行遍历整个链表，小于min的就删除，大于max就删除
使用迭代的二分查找算法：
if(max<array->data){
    跳出整个程序；
}
while(链表当前的节点比min小){
    指向下一个节点； 
}
//由于链表不能使用跳步，比如说t->next->next这样看上去快捷的运算也是会导致出现相应的时间花费，所以直接遍历好了
while(链表当前的节点比max小 || 当前节点不是NULL){
    删除当前节点；
    指向下一个节点；
}
这个复杂度是O(n);



使用两个指针分别指向两个序列，并且依次从两个序列之中取到对应长度的数字就行了
如果是链表就使用遍历来求出其中的长度
int count = 0;
while(链表的下一个不为空){
    count++;
}
如果是数组就使用步长大指针来算出整个数组的大小
int count2=0;
while(指向count2位置的东西还存有数据){
    count2+=2;
}
（注意这个数组不能越界，)
count2向前移动多久之后就可以发现数据:
令count2--;
直到探测到数据
然后根据这个序列的长度来计算那个中位数的位置
int count=0;
while(count!=中位数){
    比较两个序列中首位元素的大小
    选出其中对应小数字的序列的指针后移
    count++;
}
（注意上面的可能是偶数，要特殊处理）
输出当前的中位数
遍历其中的每一个节点，使用一个数组保存他们的绝对值，同时使用遍历来进行比对每一个元素的绝对值是否和数组上面元素一致(遍历数组上面的元素)
定义一个足够大的数组
while(当前节点不是NULL){
    比对当前节点的绝对值数据和数组中的数据；
    如果数据相等那么
        删除这个这个节点
    否则
        将这个节点的数据的绝对值加到数组中；
}



当启动这个这个函数的时候就将当前的节点加一，然后从表头开始遍历整个链表，当发现其中有任何一个节点的fraq是与调用函数之后节点的fraq相等或者比他小的时候终止遍历,并且将这个节点插入到比他小的或者相等的第一个元素的前面的位置
LocateNode(L,x){
    将当前的函数的fraq++;
    定义一个当前的头节点
    当前节点比较一下使用了当前函数节点
    如果当前节点的fraq<=使用了函数节点
    否则就将当前节点后退一格直到满足上面的条件
    在当前的节点前面插入了调用函数的节点
}



非递归算法，遍历求值就行了
int max=array->next->data;
int min=array->next->data;
int count=0
void find(line *array){
    while(当前节点的下一个节点不为空){
        比较当前节点和max哪一个更大
        更大的话就将max=当前节点的数据；
        比较当前节点的数据和min哪一个更小
        更小的话就将min=当前节点的数据；
        当前节点指向当前节点的下一个节点；
    }
}
递归算法
int min =array->next->data,int max=array->next->data;
void display(node *head){
    if(!head){
        return;
    }
    判断一下min和max大小
    如果min比这个大，那么就会直接替换
    如果max比这个小，那么就会替换
    display(head->next);
}