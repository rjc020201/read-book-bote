线性表：
typedef struct Table{
    int *head;//这是头指针，这个数组的头指针就是这个head，但是这个数组本身是动态的，数据实际有多大并不确定
    int lenght;//这是本身实际占用的内存大小
    int size;//这是系统分配的总内存大小
}table;

//初始化这个顺序表
#define Size 5;
table initTable(){
    table t;
    t.head=(int *)malloc(Size*sizeof(int));
    if(!t.head){
        printf("error");
        return -1;
    }
    t.lenght=0;
    t.size=Size;
    return t;
}


//插入操作
void insertTable(table t,int elem,int add){
    if(add>t.lenght || add<0){
        printf("插入的位置有问题请重新插入");
        return -1;
    }
    if(t.lenght==t.size){
        t.head=(int *)realloc(t.size*2*sizeof(int));
        t.size*=2;
    }
    for(int i=lenght-1;i>=add-1;i++){
        t.head[i+1]=t.head[i];
    }
    t.head[add-1]=elem;
    t.lenght++;
}
//这里可以得到的经验：1.注意检查客户的需求，注意检查自己的能力2.记住完成操作之后还是要偏移的原则，这样就不会导致偏移之后导致位置出现问题，3.注意链表的一些重要的位置定位的问题


void tableDelect(table t){
    for(int i=add;i<=lenght-1;i++){
        t.head[i]=t.head[i+1];
    }
    t.lenght--;
}
//这里可以总结的经验：每次完成什么操作之后要记得维护自己的区域

void FindTable(int add,table t){
    printf("%d \n"t.head[add]);
}

int FindTable2(table t,int findNum){
    int index=-1;
    for(int i=0;i<t.lenght;i++){
        if(i==findNum){
            index=i;
            break;
        }
    }
    return index;
}
//这个没什么好说的，该注意的只有多次匹配的问题,当然这里也有一个小技巧，这里可以形成一个-1；注意不是借助其他的方式形成的，而是自然传回的-1；这一点很有意思


void changeTable(table t,int elem,int newElem){
    for(int i=0;i<lenght;i++){
        int location=FindTable2(t,ele);
        if(location!=-1){
            t.head[location]=newElem;
        }else{
            return ;
        }
    }
}





void displayTable(table t){
    for(int i=0;i<t.lenght;i++){
        printf("%d ",t.head[i]);
    }
    printf("\n"):
}

int main(){
    table t=initTable();
    for(int i=1;i<=t.size;i++){
        scanf("%d",t.head[i-1]);
        t.lenght++;
    }
    printf("存入的数字有");
    displayTable(t);
    free(t.head);
    return 0;
}


//单链表==============================================================================================================================================
typedef struct Link{
    char elem;
    struct Link * next;
}link;


link *InitLink(){
    link p=NULL;
    p=(link *)malloc(sizeof(link));
    if(p==NULL){
        printf("NO MEMERY");
        exit -1;
    }
    p->next==NULL;
    for(int i=0;i<5;i++){
        link * tmp=NULL;
        if(p->next==NULL){
            tmp=p->next;
        }else{
            tmp=tmp->next;
        }
        tmp=(link *)malloc(sizeof(link));
        if(!tmp){
            printf("NO MEMERY");
            exit -1;
        }
        tmp->elem=i;
        tmp->next=NULL;
    }
    return p;
}
//这里是编程的思想出了问题，应该是先要创建一个新的节点后将节点加入而没有别的奇怪的操作，这是思路还没有完善

void InitLink(){
    link *p=NULL;
    link *tmp=(link *)malloc(sizeof(link));
    tmp->elem=1;
    tmp->next=NULL;
    p=tmp;
    tmp=p->next;
    for(int i=2;i<=5;i++){
        link *a=(link *)malloc(sizeof(link));
        if(a==NULL){
            printf("NO MEMERY");
            exit -1;
        }
        a->elem=i;
        a->next=NULL;
        tmp=a;
        tmp=a->next;
    }
}
//这里的思想就运用地很好

void displayTable(table t){
    link * tmp=t->next;
    while(!tmp){
        printf("%d",tmp);
        tmp=tmp->next;
    }
    printf("\n");
}


link *InsertLink(link l,int add,int elem){
    if(add<0){
        printf("Insert Number is wrong");
        exit -1;
    }
    link * tmp=NULL;
    for(int i=0;i<=add-1;i++){
        if(i=0){
            tmp=l->next;
        }else{
            tmp=tmp->next;
        }
        if(!tmp){
            printf("Insert Number is wrong");
            return l;
        }
    }
    link *a=(link *)malloc(sizeof(link));
    a->elem=elem;
    a->next=tmp->next;
    tmp->next=a;
    return l;
}
//这里的if语句明显会浪费时间，所以可以将循环的次数放出去，就可以将这个位置轻松地定位到了,2.这里的插入的时候可以明白地知道单链表一个方向的时候，知道前一个方向才可以知道后面两个的信息，想要信息最大化就要在前面找位置，不然就会导致丢掉部分信息而没有办法来插入

void DelectElem(link l,int add){
    if(add<0){
        printf("DelectNum is wrong");
        return ;
    }
    link *tmp=NULL;
    tmp=l.next;
    if(add=0){
        l->next=tmp->next;
        tmp->next=NULL;
        free(tmp);
    }
    for(int i=1;i<=add-1;i++){
        tmp=tmp->next;
    }
    link *q=tmp->next;
    tmp->next=q->next;
    q->next=NULL;
    free(q);
}

int FindElem(link l,int elem){
    link *tmp=l->next;
    int add=-1;
    int count=0;
    while(!tmp){
        if(elem==tmp->elem){
            add=count;
        }
        tmp=tmp->next;
        count++;
    }
    return add;
}


void DelectElem2(link l,int elem){
    int add=FindElem(l,elem);
    while(add!=-1){
    DelectElem(l,add);
    add=FindElem(l,elem);
    }
}
//这里有一个空执行的说法：就是先放在头节点，这样就不用再去计量次数





//静态链表================================================================================================================================
#include <stdio.h>
#define maxSize 6
typedef struct {
    int data;
    int cur;
}component;

void reserveArr(component *array);

int initArr(component *array);

void displayArr(component *array,int body);

int mallocArr(component *array);

int main(){
    component array[maxSize];
    int body=initArr(array);
    printf("静态链表是:\n");
    displayArr(array,body):
}

void reserveArr(component *array){
    for(int i=0;i<maxSize;i++){
        array[i].cur=i+1;
        array[i].data=-1;
    }
    array[maxSize-1]=0;
}
//这里的东西只是一个一个填好而已，然后再去维护最后一个位置的0，方便后续的管理

int mallocArr(component *array){
    int i=arr[0].cur;
    if(arr[0].cur){
        arr[0].cur=arr[i].cur;
    }
    return i;
}
//这里已经是拿到了然后再回来维护一下数据

int initArr(component *array){
    reserveArr(array);
    int body=mallocArr(array);
    int tempBody=body;
    for(int i=1;i<3;i++){
        int j=mallocArr(array);
        array[j].data=i;
        array[j].cur=0;
        array[tempBody].cur=j;
        tempBody=j;
    }
    return body;
}

void displayArr(component *array){
    int body=initArr(array);
    for(int i=array[body].cur;i!=0;i=array[i].cur){
        printf("%d ",array[i].data);
    }
    printf("\n");
}

void insertArr(component *array,int body,int add,char a){
    int tempBody=body;
    for(int i=1;i<add;i++){
        tempBody=array[tempBody].cur;
    }
    int j=mallocArr(array);
    array[j].data=a;
    array[j].cur=array[tempBody].cur;
    array[tempBody].cur=j;
}

void findElem(component *array,int elem,int body){
    int findNum=-1;
    int count=-1;
    for(int i=body;i!=0;i=array[i].cur){
        count++;
        if(array[i].cur==elem){
            findNum=count;
            return findNum;
        }
    }
    return findNum;
}

void DelectElem(component *array,int add,int body){

    int tempBody=body;
    if(add<0){
        printf("Delect Number is Wrong");
        return ;
    }

    for(int i=1;i<add && i!=0;i++){
        int tempBody=array[tempBody].cur;
    }
    if(i=0){
        printf("Delect Number is wrong\n");
        return ;
    }
    int j=array[tempBody].cur;
    array[tempBody].cur=array[j].cur;
    array[j].data=-1;
    array[j].cur=array[0].cur;
    array[0].cur=j;
}

//双向链表========================================================================================================================
typedef struct line{
    struct line *prior;
    int data;
    struct line *next;
}line;

line *InitLine(){
    line * head=(line *)malloc(sizeof(line));
    head->data=1;
    head->prior=NULL;
    head->next=NULL;
    line *tempLine=(line *)malloc(sizeof(line));
    tempLine->prior=head;
    head->next=tempLine;
    tempLine->data=2;
    tempLine->next=NULL;
    for(int i=2;i<3;i++){
        line *tmp=(line *)malloc(sizeof(line));
        tmp->data=i;
        tmp->next=NULL;
        tmp->prior=tempLine;
        tempLine->next=tmp;
        tempLine=tmp;
    }
    return head;
}

void displayLine(line head){
    for(line tempLine=head;tempLine==NULL;tempLine=tempLine->next){
        printf("%d ",tempLine->data);
    }
    printf("\n");
}

line * InsertLine(line *head,int add,int data){
    line *tempLine=head;
    if(add<0){
        printf("Insert Number is wrong");
    }else if(add==0){
        line *tmp=(line *)malloc(sizeof(line));
        tmp->prior=NULL;
        tmp->next=head;
        head->prior=tmp;
        tmp->data=data;
        head=tmp;
        return head;
    }
    for(int i=1;i<add;i++){
        tempLine=tempLine->next;
    }
    line *tmp=(line *)malloc(sizeof(line));
    tmp->next=tempLine->next;
    tempLine->next=tmp;
    tmp->data=data;
    tmp->prior=tempLine;
    tmp->next->prior=tmp;
}
//这里可以发现要检查一下位置，而且这个位置其实很危险，有头和尾都是非常重要的位置


//约瑟夫杯问题
line * initLine(){
    line *head=(line *)malloc(sizeof(line));
    head->data=1;
    head->prior=head;
    head->next=head;
    line tempLine=head;
    for(int i=2;i<6;i++){
        line tmp=(line *)malloc(sizeof(line));
        tmp->next=head;
        head->prior=tmp;
        tmp->data=i;
        tempLine->next=tmp;
        tmp->prior=tempLine;
        tempLine=tmp;
    }
}

void DelectLine(line *head,line *tempLine){
    tempLine->prior->next=tempLine->next;
    tempLine->next->prior=tempLine->prior;
    free(tempLine);
    tempLine=NULL;

}

int main(){
    line *head=initLine();
    tempLine=head;
    for(int i=1;;i++){
        if(tempLine->next==tempLine){
            break;
        }
        if(i==k){
            i=1;
            DelectLine(head,tempLine)
        }
        tempLine=tempLine->next;
    }
    printf("%d",tempLine->data);
    return 0;
}


//栈============================================================================================================================================
int push(int *arr,int top,int elem){
    arr[++top]=elem;
    return top;
}

int pop(int *arr,int top,int *elem){
    if(top==-1){
        printf("NONE");
        return top;
    }
    *elem=arr[top--];
    return top;
}

//链栈============================================================================================================================================
typedef struct lineStack{
    int data;
    struct lineStack *next;
}lineStack;